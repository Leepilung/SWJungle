# 정렬 알고리즘

> 시간 복잡도

<img src="../../../image/시간복잡도.png">

## 퀵 정렬

depth의 깊이 설정안해주면 특정 케이스에서 에러날 확률이 매우 높은듯.
재귀를 사용한다는 시점에서 굉장히 위험성 높은 정렬이 아닌가..
```py
def quickSort(a, start, end):
    if start < end:
        left = start
        pivot = bucket[end]
        for i in range(start,end):
            if bucket[i] < pivot:
                a[i], a[left] = a[left], a[i]
                left += 1
        a[left], a[end] = a[end], a[left]
        quickSort(a, start, left-1)
        quickSort(a, left+1, end)
quickSort(bucket, 0, len(bucket)-1)

for i in bucket:
    print(i)
```


## 병합 정렬

병합 정렬은 메모리를 굉장히 많이 차지함.

```py
def megaSort(bucket):
    if len(bucket) > 1:
        mid = len(bucket) // 2
        lbucket, rbucket = bucket[:mid],bucket[mid:]
        megaSort(lbucket)
        megaSort(rbucket)
        li, ri, i = 0,0,0
        while li < len(lbucket) and ri < len(rbucket):
            if lbucket[li] < rbucket[ri]:
                bucket[i] = lbucket[li]
                li += 1
            else:
                bucket[i] = rbucket[ri]
                ri += 1
            i += 1
        bucket[i:] = lbucket[li:] if li != len(lbucket) else rbucket[ri:]

megaSort(bucket)

for i in bucket:
    print(i)
```

## 도수 정렬

```py
def fsort(a, max) -> None:
    n = len(bucket)
    f = [0] * (max + 1)
    b = [0] * n

    for i in range(n):  f[a[i]] += 1
    for i in range(1,max+1):    f[i] += f[i-1]
    for i in range(n-1,-1,-1):  f[a[i]] -= 1; b[f[a[i]]] = a[i]
    for i in range(n):  a[i] = b[i]
```